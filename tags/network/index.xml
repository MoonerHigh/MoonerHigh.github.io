<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>network on 我的精神家园</title>
        <link>https://MoonerHigh.github.io/tags/network/</link>
        <description>Recent content in network on 我的精神家园</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 13 Feb 2023 00:44:00 +0800</lastBuildDate><atom:link href="https://MoonerHigh.github.io/tags/network/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>快速了解CDN</title>
        <link>https://MoonerHigh.github.io/p/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3cdn/</link>
        <pubDate>Mon, 13 Feb 2023 00:44:00 +0800</pubDate>
        
        <guid>https://MoonerHigh.github.io/p/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3cdn/</guid>
        <description>&lt;p&gt;CDN的全称为Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单来说，CDN通过在网络节点各处放置边缘机房，当用户请求时使用负载均衡技术使用户可以就近取得内容，从而解决网络拥挤的状况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cdn的实现原理&#34;&gt;CDN的实现原理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 CDN的基本原理为反向代理。反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器， 并将服务器上的请求结果通过代理服务器返回给请求连接的的客户端。此时，代理服务器的表现为一个节点服务器，通过部署大量的代理服务器，就可以达到多节点CDN的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/63e90c4f4757feff33c353a4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;CDN.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当用户在浏览器中输入域名进行访问时，会被DNS服务器进行解析，域名在被解析之后，会指向CDN域名服务器，CDN域名服务器这个时候会返回域名的CNAME记录，然后再对CNAME记录进行解析，这个时候会访问负载均衡服务器得到缓存服务器的地址，最后再去对IP进行访问从而得到数据并返回数据给浏览器回显。&lt;/p&gt;
&lt;h2 id=&#34;cdn解决了什么问题&#34;&gt;CDN解决了什么问题？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用大量边缘服务器通过负载均衡减少网络拥堵&lt;/li&gt;
&lt;li&gt;降低服务器带宽成本&lt;/li&gt;
&lt;li&gt;当源服务器宕机时，CDN缓存服务器可以提供服务&lt;/li&gt;
&lt;li&gt;压缩静态内容，从而提高访问速度&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>快速了解TCP协议</title>
        <link>https://MoonerHigh.github.io/p/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3tcp%E5%8D%8F%E8%AE%AE/</link>
        <pubDate>Fri, 10 Feb 2023 22:32:46 +0800</pubDate>
        
        <guid>https://MoonerHigh.github.io/p/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3tcp%E5%8D%8F%E8%AE%AE/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;💡 TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/TCP/33012?fromModule=lemma_inlink&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCP&lt;/a&gt; 和&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/IP/224599?fromModule=lemma_inlink&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;IP&lt;/a&gt;两个协议，而是指一个由&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/FTP/13839?fromModule=lemma_inlink&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;FTP&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/SMTP/175887?fromModule=lemma_inlink&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SMTP&lt;/a&gt;、TCP、&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/UDP/571511?fromModule=lemma_inlink&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;UDP&lt;/a&gt;、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tcpip分层管理&#34;&gt;TCP/IP分层管理&lt;/h3&gt;
&lt;p&gt;TCP/IP协议族按层次分可以分为以下四层。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;应用层-传输层-网络层-数据链路层&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP/IP分层的好处是可以解耦，如果互联网只由一个协议统筹，某个地方需要改变设计时，需要把整体都替换掉，而分层之后只需要把变动的层替换掉即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/63e50b984757feff33ce609e.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;OSI-TCP_IP.jpeg&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcpip通信传输流&#34;&gt;TCP/IP通信传输流&lt;/h3&gt;
&lt;p&gt;利用TCP/IP协议簇进行通信时，会通过分层顺序与对方进行确认，下面我们用HTTP来举例说明一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端作为发送端在应用层使用HTTP协议向某一个web页面发送请求。&lt;/li&gt;
&lt;li&gt;为了传输方便，在传输层(TCP协议)把从应用层接收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。&lt;/li&gt;
&lt;li&gt;在网络层（IP协议），增加作为通信地址的MAC地址然后转发给数据链路层。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当接收端的服务器在链路层收到数据，按序往上层发送，一直到应用层，才算能真正接收到客户端发来的HTTP请求。&lt;/p&gt;
&lt;p&gt;发送端在层与层之间传输数据时，每经过一层必定会被打上该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层必会把对应的首部消除。&lt;/p&gt;
&lt;h3 id=&#34;tcp三次握手&#34;&gt;TCP三次握手&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;最开始的时候客户端和服务端都是处于CLOSED状态，主动打开的是客户端，被动打开的是服务端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/114bd9b53c554319ae0db15b57b472b8.gif#pic_center&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;https://img-blog.csdnimg.cn/114bd9b53c554319ae0db15b57b472b8.gif#pic_center&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TCP服务器先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN状态;&lt;/li&gt;
&lt;li&gt;TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同步为SYN=1,同时选择一个初始序列号seq=x,此时客户端进程进入了SYN-SENT（同步到已发送）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。&lt;/li&gt;
&lt;li&gt;TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该ACK=1,SYN=1,确认号是ack=x+1,同时也要初始化一个序列号seq=y，此时TCP服务器进程进入了SYN-RCVD状态。这个报文也不能携带数据，但是同样要消耗一个序号。&lt;/li&gt;
&lt;li&gt;TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1,ack=y+1,自己的序列号seq=x+1,此时TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗信号。&lt;/li&gt;
&lt;li&gt;当服务器收到客户端的确认后也进入ESTABLISHED状态，此时双方就可以开始通信了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;为什么TCP客户端最后还要发送一次确认呢？&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tcp的释放-四次挥手&#34;&gt;TCP的释放-四次挥手&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/0c17d72769aa4bd2b95bbaee1749b39d.gif#pic_center&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;https://img-blog.csdnimg.cn/0c17d72769aa4bd2b95bbaee1749b39d.gif#pic_center&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://weread.qq.com/web/bookDetail/3da32b505dd9f43da9a1aca&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图解HTTP-上野宣-微信读书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qzcsu/article/details/72861891&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;两张动图-彻底明白TCP的三次握手与四次挥手_小书go的博客-CSDN博客_tcp三次握手&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
