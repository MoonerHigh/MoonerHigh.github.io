[{"content":" TCP/IP分层管理 TCP/IP协议族按层次分可以分为以下四层。\n应用层-传输层-网络层-数据链路层\nTCP/IP分层的好处是可以解耦，如果互联网只由一个协议统筹，某个地方需要改变设计时，需要把整体都替换掉，而分层之后只需要把变动的层替换掉即可。\nTCP/IP通信传输流 利用TCP/IP协议簇进行通信时，会通过分层顺序与对方进行确认，下面我们用HTTP来举例说明一下。\n客户端作为发送端在应用层使用HTTP协议向某一个web页面发送请求。 为了传输方便，在传输层(TCP协议)把从应用层接收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP协议），增加作为通信地址的MAC地址然后转发给数据链路层。 当接收端的服务器在链路层收到数据，按序往上层发送，一直到应用层，才算能真正接收到客户端发来的HTTP请求。\n发送端在层与层之间传输数据时，每经过一层必定会被打上该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层必会把对应的首部消除。\nTCP三次握手 最开始的时候客户端和服务端都是处于CLOSED状态，主动打开的是客户端，被动打开的是服务端。\nTCP服务器先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN状态; TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同步为SYN=1,同时选择一个初始序列号seq=x,此时客户端进程进入了SYN-SENT（同步到已发送）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。 TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该ACK=1,SYN=1,确认号是ack=x+1,同时也要初始化一个序列号seq=y，此时TCP服务器进程进入了SYN-RCVD状态。这个报文也不能携带数据，但是同样要消耗一个序号。 TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1,ack=y+1,自己的序列号seq=x+1,此时TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗信号。 当服务器收到客户端的确认后也进入ESTABLISHED状态，此时双方就可以开始通信了。 为什么TCP客户端最后还要发送一次确认呢？\n主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\nTCP的释放-四次挥手 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。\n参考资料\n图解HTTP-上野宣-微信读书\n两张动图-彻底明白TCP的三次握手与四次挥手_小书go的博客-CSDN博客_tcp三次握手\n","date":"2023-02-10T22:32:46+08:00","permalink":"https://MoonerHigh.github.io/p/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3tcp%E5%8D%8F%E8%AE%AE/","title":"快速了解TCP协议"},{"content":"分享之前接单私活写的一个爬虫单,客户要求爬取微信公众号的标题，所属公众号，文章发布时间，文章地址，代码本身并不复杂，直接采用搜狗引擎里的微信公众号接口即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 import time import urllib.parse import urllib.request import random import requests import parsel import csv from tqdm import tqdm # 爬取内容写入csv文件 def download_csv(title_str, name, otherStyleTime, article_url): dit = { \u0026#39;标题\u0026#39;: title_str, \u0026#39;公众号\u0026#39;: name, \u0026#39;文章发布时间\u0026#39;: otherStyleTime, \u0026#39;文章地址\u0026#39;: article_url, } csv_writer.writerow(dit) # print(title_str, name, otherStyleTime, article_url) # 解析响应内容 def parse_lable(response): selector = parsel.Selector(response.text) lis = selector.css(\u0026#39;.news-list li\u0026#39;) for li in lis: title_list = li.css(\u0026#39;.txt-box h3 a::text\u0026#39;).getall() num = len(title_list) if num == 1: title_str = keyword + title_list[0] else: title_str = keyword.join(title_list) href = li.css(\u0026#39;.txt-box h3 a::attr(href)\u0026#39;).get() article_url = \u0026#39;https://weixin.sogou.com\u0026#39; + href name = li.css(\u0026#39;.s-p a::text\u0026#39;).get() date = li.css(\u0026#39;.s-p::attr(t)\u0026#39;).get() timeArray = time.localtime(int(date)) otherStyleTime = time.strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, timeArray) download_csv(title_str, name, otherStyleTime, article_url) # 访问搜狗视频获取最新Cookie def get_new_cookies(): # 搜狗视频url url = \u0026#39;https://v.sogou.com/v?ie=utf8\u0026amp;query=\u0026amp;p=40030600\u0026#39; headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36\u0026#39;} rst = requests.get(url=url, headers=headers, allow_redirects=False) cookies = rst.cookies.get_dict() return cookies.get(\u0026#39;SNUID\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: keyword = input(\u0026#34;请输入检索内容：\u0026#34;) f = open(f\u0026#39;公众号文章_\u0026#39; + keyword + \u0026#39;.csv\u0026#39;, mode=\u0026#39;a\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\u0026#39;) csv_writer = csv.DictWriter(f, fieldnames=[\u0026#39;标题\u0026#39;, \u0026#39;公众号\u0026#39;, \u0026#39;文章发布时间\u0026#39;, \u0026#39;文章地址\u0026#39;]) csv_writer.writeheader() SNUID=get_new_cookies() headers = { \u0026#39;Cookie\u0026#39;: f\u0026#39;IPLOC=CN5101; SUID=A08DB0753822910A0000000062D4E15C; SUV=1658118495598633; \u0026#39; f\u0026#39;ppinf=5|1658121514|1659331114\u0026#39; f\u0026#39;|dHJ1c3Q6MToxfGNsaWVudGlkOjQ6MjAxN3x1bmlxbmFtZTozNjolRTglODclQUElRTUlOUMlQTglRTclOEIlQUMlRTglQTElOEN8Y3J0OjEwOjE2NTgxMjE1MTR8cmVmbmljazozNjolRTglODclQUElRTUlOUMlQTglRTclOEIlQUMlRTglQTElOEN8dXNlcmlkOjQ0Om85dDJsdU5QS01HS01jX2o5WjM5aG5XY1I4d29Ad2VpeGluLnNvaHUuY29tfA; pprdig=IjtTyvBfu3HPN0JuCq-GC-ua97U2qrVaL1lKmQcS5ISR8XkUoZxSWujpBlyP0zSHSItfzFGPWnzTuIhBHYtUwY-PI6COy-6I8RcER_mopugTqcBlwdO-Sc_p7j8a51jQaet93CEJ-MdpiSceBG_Nmu5cLTPN5XhC_3B92CSovak; ppinfo=80456da5d9; passport=5|1658121514|1659331114|dHJ1c3Q6MToxfGNsaWVudGlkOjQ6MjAxN3x1bmlxbmFtZTozNjolRTglODclQUElRTUlOUMlQTglRTclOEIlQUMlRTglQTElOEN8Y3J0OjEwOjE2NTgxMjE1MTR8cmVmbmljazozNjolRTglODclQUElRTUlOUMlQTglRTclOEIlQUMlRTglQTElOEN8dXNlcmlkOjQ0Om85dDJsdU5QS01HS01jX2o5WjM5aG5XY1I4d29Ad2VpeGluLnNvaHUuY29tfA|242a929d54|IjtTyvBfu3HPN0JuCq-GC-ua97U2qrVaL1lKmQcS5ISR8XkUoZxSWujpBlyP0zSHSItfzFGPWnzTuIhBHYtUwY-PI6COy-6I8RcER_mopugTqcBlwdO-Sc_p7j8a51jQaet93CEJ-MdpiSceBG_Nmu5cLTPN5XhC_3B92CSovak; sgid=29-55943661-AWLU7Sr6zRRQxuX98MZMHMw; wuid=1658155657696; VIDEO_DEBUG=off; SNUID={SNUID}; ariaDefaultTheme=undefined; ppmdig=16581727390000000ba8e97bdbf22bfcefd4d50f43d86a61\u0026#39;, \u0026#39;Host\u0026#39;: \u0026#39;weixin.sogou.com\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 \u0026#39; \u0026#39;Safari/537.36\u0026#39;, } # proxies = { # \u0026#39;http\u0026#39;:\u0026#39;http://113.222.29.169:22008\u0026#39;, # \u0026#39;https\u0026#39;: \u0026#39;https://113.222.29.169:22008\u0026#39;, # } print(\u0026#39;-------------开始爬取-------------\u0026#39;) for page in tqdm(range(1000 + 1)): url = f\u0026#39;https://weixin.sogou.com/weixin?query={urllib.parse.quote(keyword)}\u0026amp;_sug_type_=\u0026amp;s_from=input\u0026amp;_sug_=n\u0026#39; \\ f\u0026#39;\u0026amp;type=2\u0026amp;page={page}\u0026amp;ie=utf8 \u0026#39; try: response = requests.get(url=url, headers=headers) parse_lable(response) # 控制爬取频率 # time.sleep(random.randint(8, 10)) except KeyboardInterrupt: print(\u0026#39;\\n-----------------操作中止---------------------\u0026#39;) print(\u0026#39;-------------爬取完成------------\u0026#39;) 代码本身很简单，关键在于搜狗的反爬机制，Cookie很容易失效，可能爬两次程序就挂了，客户自己没有办法调试。\n那么直接看Cookie这一项，他是由多个key-value拼接成的，经过解析，发现起决定性作用的只有key为SUID的这一项。\n现在只需要直接获取最新的Cookie拿到SUID的value拼装成一个新Cookie,定制其成为新的请求头就可以再去访问页面就可以了。\n至于新的Cookie怎么来…..\n解决方法其实很简单，搜狗引擎提供了很多接口，都是兄弟产品，我们现在操作的是weixin.sougou.com,试着访问其他接口，比如搜狗视频v.sogou.com，发现Cookie的规则是一致的，但是关键字的值并不一样，我只需要访问url再取其Cookie就可以了。对搜狗视频的访问操作不足以触发其反爬机制，这就形成了一个闭环。\n最终的方案是在程序启动时，访问搜狗视频接口，拿到新的Cookie补充给headers里的Cookie,定制一个全新的请求头，再去循环爬取操作，最终写入文件。\n其他代码都是孰能生巧，解决问题思路很重要。\n","date":"2023-02-01T01:32:50+08:00","permalink":"https://MoonerHigh.github.io/p/%E6%90%9C%E7%8B%97%E7%88%AC%E8%99%AB/","title":"搜狗爬虫"},{"content":"New和Make的区别 以下是Go1.19中对new()和make()函数的解释：\n1 2 3 4 // The new built-in function allocates memory. The first argument is a type, // not a value, and the value returned is a pointer to a newly // allocated zero value of that type. func new(Type) *Type new()是一个新的分配内存的函数，第一个参数是类型，不是值，返回的值是指向该类型零值的指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // The make built-in function allocates and initializes an object of type // slice, map, or chan (only). Like new, the first argument is a type, not a // value. Unlike new, make\u0026#39;s return type is the same as the type of its // argument, not a pointer to it. The specification of the result depends on // the type: // // Slice: The size specifies the length. The capacity of the slice is // equal to its length. A second integer argument may be provided to // specify a different capacity; it must be no smaller than the // length. For example, make([]int, 0, 10) allocates an underlying array // of size 10 and returns a slice of length 0 and capacity 10 that is // backed by this underlying array. // Map: An empty map is allocated with enough space to hold the // specified number of elements. The size may be omitted, in which case // a small starting size is allocated. // Channel: The channel\u0026#39;s buffer is initialized with the specified // buffer capacity. If zero, or the size is omitted, the channel is // unbuffered. func make(t Type, size ...IntegerType) Type make()函数用于初始化slice,map和channel。和new()比较像的是第一个参数也是一个类型，不是值。区别于new的地方在于make()返回的值和他参数类型是一样的。第二个类型size是一个可变长类型的参数，作用如下:\n1 2 3 4 m := make(map[int]string, 5) s := make([]int, 5, 10) channel := make(chan string, 5) fmt.Println(m, s, channel) 初始化一个slice,传入第一个参数为类型，第二个参数为长度，第三个参数为容量，容量不可以小于长度。初始化map的可变参数只有容量cap,而初始化channel的可变参数为缓冲大小。\n","date":"2023-01-29T12:04:17+08:00","permalink":"https://MoonerHigh.github.io/p/new-or-make/","title":"New or Make"},{"content":"堆内存与栈内存 程序会在两个地方为变量分配内存，一个是全局的堆空间用来动态分配内存，另一个是goroutine的栈空间，Go语言拥有自动的垃圾回收机制，我们不需要关心内存到底是分配在堆上还是栈上，但是从性能的角度出发，分配在栈空间还是堆空间差异较大。\n在函数中申请一个对象，如果分配在栈上，函数执行完毕自动回收，如果分配在堆上，则在函数执行完毕后某个时间点进行垃圾回收。\n在栈上分配或者回收内存的开销很低，只需要两个CPU指令，一个是Push,一个是Pop,Push代表分配内存，Pop代表释放内存。在栈上分配内存，消耗的仅是将内存分配到栈上的时间，内存的IO速度通常能够达到30GB/s，因此在栈上分配内存效率比较高。\n在堆上分配内存，一个很大的额外开销是垃圾回收，Go语言使用的是清除标记算法，并在此基础上，使用了三色标记法和写屏障算法，提高了效率。\n逃逸分析 Go语言中，堆内存是通过垃圾回收机制自动管理的，那么Go的编译器如何知道内存是分配在栈上还是堆上呢？编译器决定内存分配位置的方式，就叫逃逸分析。逃逸分析由编译器完成，作用于编译阶段。\n指针逃逸 在函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数的结束而回收，因此只能分配在堆上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; type Demo struct { name string } func createDemo(name string) *Demo { d := new(Demo) d.name = name return d } func main() { demo := createDemo(\u0026#34;demo\u0026#34;) fmt.Println(demo) } 1 go run -gcflags \u0026#34;-m -l\u0026#34; Demo30.go ./Demo30.go:9:17: leaking param: name ./Demo30.go:10:10: new(Demo) escapes to heap ./Demo30.go:16:13: \u0026hellip; argument does not escape \u0026amp;{demo}\nnew(Demo) escapes to heap说明new(Demo)逃逸到了堆上\nInterface动态类型逃逸 空接口Interface{}可以表示任何类型，如果函数的参数为interface{},编译期无法确定具体类型，则会发生逃逸。\n在上面的例子中\n1 2 3 4 func main() { demo := createDemo(\u0026#34;demo\u0026#34;) fmt.Println(demo) } 我们将main函数中的局部变量demo作为实际参数传给fmt.Println方法，\nfmt.Println方法的实现如下\n1 2 3 func Println(a ...any) (n int, err error) { return Fprintln(os.Stdout, a...) } 参数类型为a…any即interface{}类型，因此发生了逃逸。\n栈空间不足 超过一定大小的局部变量会逃逸到堆上，变量大小不确定，也会逃逸到堆上。\n闭包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func Increment() func() int { n := 0 return func() int { n++ return n } } func main() { increment := Increment() fmt.Println(increment()) fmt.Println(increment()) } Increment()返回值是一个闭包函数，该匿名函数访问了外部变量n,外部变量n将一直存在，直到increment被销毁。变量n的内存不能随着函数Increment()推出而被销毁，因此将会逃逸到堆上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ➜ Demo go run -gcflags=-m Demo31.go # command-line-arguments ./Demo31.go:5:6: can inline Increment ./Demo31.go:7:9: can inline Increment.func1 ./Demo31.go:14:24: inlining call to Increment ./Demo31.go:7:9: can inline main.func1 ./Demo31.go:15:23: inlining call to main.func1 ./Demo31.go:15:13: inlining call to fmt.Println ./Demo31.go:16:23: inlining call to main.func1 ./Demo31.go:16:13: inlining call to fmt.Println ./Demo31.go:6:2: moved to heap: n ./Demo31.go:7:9: func literal escapes to heap ./Demo31.go:14:24: func literal does not escape ./Demo31.go:15:13: ... argument does not escape ./Demo31.go:15:23: ~R0 escapes to heap ./Demo31.go:16:13: ... argument does not escape ./Demo31.go:16:23: ~R0 escapes to heap 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能\n参考链接：Go 逃逸分析\n","date":"2023-01-27T13:58:43+08:00","permalink":"https://MoonerHigh.github.io/p/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/","title":"逃逸分析"},{"content":"SQL优化 查询SQL尽量不要使用select *，而是使用具体字段\nselect * 进行查询时，很可能不会用到索引，避免造成全表扫描 节省资源，减少网络开销 避免在where子句中使用or来连接条件\n反例 1 select * from employee where id = 1 or salary = 3000; 正例 使用union all\n1 2 3 select * from employee where id=1 union all select * from employee where salary = 3000; 分开两条SQL写\n1 2 select * from employee where id=1; select * from employee where salary=3000; ","date":"2023-01-13T10:48:35+08:00","permalink":"https://MoonerHigh.github.io/p/sql%E4%BC%98%E5%8C%96/","title":"SQL优化"}]