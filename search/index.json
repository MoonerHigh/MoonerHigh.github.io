[{"content":"New和Make的区别 以下是Go1.19中对new()和make()函数的解释：\n1 2 3 4 // The new built-in function allocates memory. The first argument is a type, // not a value, and the value returned is a pointer to a newly // allocated zero value of that type. func new(Type) *Type new()是一个新的分配内存的函数，第一个参数是类型，不是值，返回的值是指向该类型零值的指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // The make built-in function allocates and initializes an object of type // slice, map, or chan (only). Like new, the first argument is a type, not a // value. Unlike new, make\u0026#39;s return type is the same as the type of its // argument, not a pointer to it. The specification of the result depends on // the type: // // Slice: The size specifies the length. The capacity of the slice is // equal to its length. A second integer argument may be provided to // specify a different capacity; it must be no smaller than the // length. For example, make([]int, 0, 10) allocates an underlying array // of size 10 and returns a slice of length 0 and capacity 10 that is // backed by this underlying array. // Map: An empty map is allocated with enough space to hold the // specified number of elements. The size may be omitted, in which case // a small starting size is allocated. // Channel: The channel\u0026#39;s buffer is initialized with the specified // buffer capacity. If zero, or the size is omitted, the channel is // unbuffered. func make(t Type, size ...IntegerType) Type make()函数用于初始化slice,map和channel。和new()比较像的是第一个参数也是一个类型，不是值。区别于new的地方在于make()返回的值和他参数类型是一样的。第二个类型size是一个可变长类型的参数，作用如下:\n1 2 3 4 m := make(map[int]string, 5) s := make([]int, 5, 10) channel := make(chan string, 5) fmt.Println(m, s, channel) 初始化一个slice,传入第一个参数为类型，第二个参数为长度，第三个参数为容量，容量不可以小于长度。初始化map的可变参数只有容量cap,而初始化channel的可变参数为缓冲大小。\n","date":"2023-01-29T12:04:17+08:00","permalink":"https://MoonerHigh.github.io/p/new-or-make/","title":"New or Make"},{"content":"堆内存与栈内存 程序会在两个地方为变量分配内存，一个是全局的堆空间用来动态分配内存，另一个是goroutine的栈空间，Go语言拥有自动的垃圾回收机制，我们不需要关心内存到底是分配在堆上还是栈上，但是从性能的角度出发，分配在栈空间还是堆空间差异较大。\n在函数中申请一个对象，如果分配在栈上，函数执行完毕自动回收，如果分配在堆上，则在函数执行完毕后某个时间点进行垃圾回收。\n在栈上分配或者回收内存的开销很低，只需要两个CPU指令，一个是Push,一个是Pop,Push代表分配内存，Pop代表释放内存。在栈上分配内存，消耗的仅是将内存分配到栈上的时间，内存的IO速度通常能够达到30GB/s，因此在栈上分配内存效率比较高。\n在堆上分配内存，一个很大的额外开销是垃圾回收，Go语言使用的是清除标记算法，并在此基础上，使用了三色标记法和写屏障算法，提高了效率。\n逃逸分析 Go语言中，堆内存是通过垃圾回收机制自动管理的，那么Go的编译器如何知道内存是分配在栈上还是堆上呢？编译器决定内存分配位置的方式，就叫逃逸分析。逃逸分析由编译器完成，作用于编译阶段。\n指针逃逸 在函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数的结束而回收，因此只能分配在堆上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; type Demo struct { name string } func createDemo(name string) *Demo { d := new(Demo) d.name = name return d } func main() { demo := createDemo(\u0026#34;demo\u0026#34;) fmt.Println(demo) } 1 go run -gcflags \u0026#34;-m -l\u0026#34; Demo30.go ./Demo30.go:9:17: leaking param: name ./Demo30.go:10:10: new(Demo) escapes to heap ./Demo30.go:16:13: \u0026hellip; argument does not escape \u0026amp;{demo}\nnew(Demo) escapes to heap说明new(Demo)逃逸到了堆上\nInterface动态类型逃逸 空接口Interface{}可以表示任何类型，如果函数的参数为interface{},编译期无法确定具体类型，则会发生逃逸。\n在上面的例子中\n1 2 3 4 func main() { demo := createDemo(\u0026#34;demo\u0026#34;) fmt.Println(demo) } 我们将main函数中的局部变量demo作为实际参数传给fmt.Println方法，\nfmt.Println方法的实现如下\n1 2 3 func Println(a ...any) (n int, err error) { return Fprintln(os.Stdout, a...) } 参数类型为a…any即interface{}类型，因此发生了逃逸。\n栈空间不足 超过一定大小的局部变量会逃逸到堆上，变量大小不确定，也会逃逸到堆上。\n闭包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func Increment() func() int { n := 0 return func() int { n++ return n } } func main() { increment := Increment() fmt.Println(increment()) fmt.Println(increment()) } Increment()返回值是一个闭包函数，该匿名函数访问了外部变量n,外部变量n将一直存在，直到increment被销毁。变量n的内存不能随着函数Increment()推出而被销毁，因此将会逃逸到堆上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ➜ Demo go run -gcflags=-m Demo31.go # command-line-arguments ./Demo31.go:5:6: can inline Increment ./Demo31.go:7:9: can inline Increment.func1 ./Demo31.go:14:24: inlining call to Increment ./Demo31.go:7:9: can inline main.func1 ./Demo31.go:15:23: inlining call to main.func1 ./Demo31.go:15:13: inlining call to fmt.Println ./Demo31.go:16:23: inlining call to main.func1 ./Demo31.go:16:13: inlining call to fmt.Println ./Demo31.go:6:2: moved to heap: n ./Demo31.go:7:9: func literal escapes to heap ./Demo31.go:14:24: func literal does not escape ./Demo31.go:15:13: ... argument does not escape ./Demo31.go:15:23: ~R0 escapes to heap ./Demo31.go:16:13: ... argument does not escape ./Demo31.go:16:23: ~R0 escapes to heap 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能\n参考链接：Go 逃逸分析\n","date":"2023-01-27T13:58:43+08:00","permalink":"https://MoonerHigh.github.io/p/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/","title":"逃逸分析"},{"content":"SQL优化 查询SQL尽量不要使用select *，而是使用具体字段\nselect * 进行查询时，很可能不会用到索引，避免造成全表扫描 节省资源，减少网络开销 避免在where子句中使用or来连接条件\n反例 1 select * from employee where id = 1 or salary = 3000; 正例 使用union all\n1 2 3 select * from employee where id=1 union all select * from employee where salary = 3000; 分开两条SQL写\n1 2 select * from employee where id=1; select * from employee where salary=3000; ","date":"2023-01-13T10:48:35+08:00","permalink":"https://MoonerHigh.github.io/p/sql%E4%BC%98%E5%8C%96/","title":"SQL优化"}]